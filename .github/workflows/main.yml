# A descriptive name for the workflow, shown in the GitHub Actions UI.
# This name helps identify the workflow in the "Actions" tab of the repository.
name: Android Super Partition Repack (Build & Release)

# This section defines how the workflow is triggered.
on:
  # 'workflow_dispatch' allows you to run this workflow manually from the
  # "Actions" tab in your GitHub repository.
  workflow_dispatch:
    # 'inputs' defines the parameters you can provide when running the workflow manually.
    inputs:
      stock_firmware_url:
        description: 'URL to the stock firmware (Direct HTTP, MEGA.nz, etc.).'
        required: true
        type: string
      custom_system_url:
        description: 'Custom ROM download URL (.img, .img.xz, .zip supported)'
        required: true
        type: string
      upload_to_release:
        description: 'Upload the final artifact as a GitHub Release?'
        required: true
        type: boolean
        default: true
      no_flash_flag:
        description: 'The flag to prevent the script from trying to flash (e.g., -n, --no-flash). Leave blank if none.'
        required: false
        type: string
      empty_product:
        description: 'Use empty product.img (-e flag)'
        required: false
        type: boolean
        default: false
      empty_system_ext:
        description: 'Use empty system_ext.img (-x flag)'
        required: false
        type: boolean
        default: false
      silent_mode:
        description: 'Silent mode for the script (-s flag)'
        required: false
        type: boolean
        default: true
      writable:
        description: 'Make partitions writable (-w flag)'
        required: false
        type: boolean
        default: false
      purge_all:
        description: 'Purge repacksuper directory after use (-p flag)'
        required: false
        type: boolean
        default: true

# A workflow is made up of one or more 'jobs'. This job is named 'repack-super'.
jobs:
  repack-super:
    # 'runs-on' specifies the type of virtual machine to run the job on.
    runs-on: ubuntu-latest
    # 'permissions' are required to create GitHub Releases.
    permissions:
      contents: write
    # 'steps' are a sequence of tasks that will be executed as part of the job.
    steps:
    # This step checks out a copy of your repository onto the runner.
    - name: Checkout repository
      uses: actions/checkout@v4

    # --- START OF DISK SPACE CLEANUP ---
    - name: Free disk space
      run: |
        echo "Initial disk space:"
        df -h
        sudo rm -rf /usr/share/dotnet /usr/local/lib/android /opt/ghc
        sudo docker image prune --all --force
        echo "Disk space after manual cleanup:"
        df -h

    # This step installs the necessary dependencies for the script to run.
    - name: Install Dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y android-sdk-libsparse-utils tar xz-utils liblz4-tool unzip p7zip-full file wget curl megatools f2fs-tools

    # This step ensures the main script is present and executable.
    - name: Verify and Prepare Script
      run: |
        if [ ! -f "./repacksuper.sh" ]; then echo "✗ Error: repacksuper.sh not found" && exit 1; fi
        chmod +x ./repacksuper.sh

    # This step creates a dedicated directory for all the work.
    - name: Create working directory
      run: mkdir -p work

    # This step generates a unique hash of the firmware URL for caching.
    - name: Generate Firmware URL Hash for Cache
      id: generate_hash
      run: |
        echo "fw_hash=$(echo -n "${{ github.event.inputs.stock_firmware_url }}" | md5sum | cut -d' ' -f1)" >> $GITHUB_OUTPUT

    # This step caches the downloaded stock firmware to speed up subsequent runs.
    - name: Cache Stock Firmware
      id: cache-stock
      uses: actions/cache@v4
      with:
        path: work/stock_firmware.zip
        key: ${{ runner.os }}-stock-${{ steps.generate_hash.outputs.fw_hash }}

    # This step downloads and extracts the stock super.img.
    - name: Download and Extract Stock Firmware
      run: |
        cd work
        FIRMWARE_URL="${{ github.event.inputs.stock_firmware_url }}"
        if [ "${{ steps.cache-stock.outputs.cache-hit }}" != 'true' ]; then
          echo "==> No cache hit. Downloading stock firmware..."
          if [[ $FIRMWARE_URL == *"mega.nz"* ]]; then megadl -o stock_firmware.zip "$FIRMWARE_URL"; else wget --user-agent="Mozilla/5.0" --content-disposition -O stock_firmware.zip --tries=5 --wait=10 "$FIRMWARE_URL"; fi
        else
          echo "==> Stock firmware cache was successfully restored."
        fi
        if [ ! -s "stock_firmware.zip" ]; then echo "✗ CRITICAL ERROR: Failed to download or find stock firmware." && exit 1; fi
        AP_FILENAME=$(unzip -l "stock_firmware.zip" | grep -i -o -E "AP_.*\.tar\.md5" | head -n 1)
        if [ -z "$AP_FILENAME" ]; then echo "✗ Error: AP file not found."; unzip -l "stock_firmware.zip"; exit 1; fi
        unzip -o -j "stock_firmware.zip" "$AP_FILENAME"
        rm "stock_firmware.zip"
        tar -xvf "$AP_FILENAME" --wildcards '*super.img*.lz4'
        rm "$AP_FILENAME"
        SUPER_LZ4=$(ls *super.img*.lz4 | head -n 1)
        lz4 -d "$SUPER_LZ4" stock_super_sparse.img
        rm "$SUPER_LZ4"
        if [ ! -f "stock_super_sparse.img" ]; then echo "✗ Error: Failed to create sparse stock_super.img." && exit 1; fi

    # This step downloads and prepares the custom system.img.
    - name: Download and Prepare Custom system.img
      run: |
        cd work
        wget -O custom_rom_package "${{ github.event.inputs.custom_system_url }}"
        if [ ! -s "custom_rom_package" ]; then echo "✗ Error: Failed to download custom ROM." && exit 1; fi
        FILE_TYPE=$(file -b custom_rom_package)
        case "$FILE_TYPE" in
          *"XZ compressed data"*)      mv custom_rom_package c.img.xz && unxz c.img.xz && mv c.img custom_system.img ;;
          *"Zip archive data"*)
            unzip -o custom_rom_package ; rm custom_rom_package
            SYSTEM_IMG_FILE=$(find . -maxdepth 1 -name "system.img" -o -name "system.raw.img" | head -n 1)
            if [ -z "$SYSTEM_IMG_FILE" ]; then echo "✗ Error: system.img not found in ZIP." && exit 1; fi
            mv "$SYSTEM_IMG_FILE" custom_system.img ;;
          *"7z archive data"*)
            7z x custom_rom_package ; rm custom_rom_package
            SYSTEM_IMG_FILE=$(find . -maxdepth 1 -name "system.img" -o -name "system.raw.img" | head -n 1)
            if [ -z "$SYSTEM_IMG_FILE" ]; then echo "✗ Error: system.img not found in 7z archive." && exit 1; fi
            mv "$SYSTEM_IMG_FILE" custom_system.img ;;
          *)                            mv custom_rom_package custom_system.img ;;
        esac
        if [ ! -f "custom_system.img" ]; then echo "✗ Error: custom_system.img not created." && exit 1; fi

    # NEW STEP: Ensure the image is a raw image to guarantee it can be mounted.
    # This fixes the "bad superblock" error by converting sparse images that were misidentified.
    - name: Convert to Raw Image (if necessary)
      run: |
        cd work
        echo "==> Ensuring custom_system.img is a raw image..."
        # Create a temporary name for the output.
        mv custom_system.img custom_system.temp.img
        # simg2img will convert a sparse image to raw, or just copy a raw image.
        simg2img custom_system.temp.img custom_system.img
        # Clean up the temporary file.
        rm custom_system.temp.img
        echo "==> Conversion complete."

    # This step modifies the build.prop file inside the custom system image for branding.
    - name: Modify build.prop for Branding
      run: |
        cd work
        echo "==> Detecting filesystem type for custom_system.img..."
        FS_TYPE=$(sudo blkid -o value -s TYPE custom_system.img 2>/dev/null)
        echo "==> Filesystem detected: ${FS_TYPE:-'Unknown'}"
        case "$FS_TYPE" in
          "ext4"|"f2fs")
            echo "==> Filesystem is '$FS_TYPE'. Attempting to mount for modification..."
            mkdir -p mnt_system
            if sudo mount -t "$FS_TYPE" -o loop custom_system.img mnt_system; then
              echo "==> Mount successful."
              if [ -f "mnt_system/system/build.prop" ]; then
                echo "==> Modifying build.prop..."
                sudo sed -i 's|ro.build.id=.*|ro.build.id=Built.By.Minh2077.Script|g' mnt_system/system/build.prop
                echo "==> build.prop modified."
              else
                echo "⚠️ Warning: build.prop not found at mnt_system/system/build.prop. Skipping."
              fi
              sudo umount mnt_system
              rm -rf mnt_system
            else
              echo "✗ Warning: Failed to mount the $FS_TYPE image. Skipping build.prop modification."
            fi
            ;;
          "erofs")
            echo "⚠️ Warning: Filesystem is EROFS (read-only). Modification is not possible. Skipping."
            ;;
          *)
            echo "⚠️ Warning: Unsupported or unknown filesystem ('${FS_TYPE:-'Unknown'}'). Skipping modification."
            ;;
        esac

    # This step prepares the command-line flags for the 'repacksuper.sh' script.
    - name: Prepare repacksuper.sh flags
      id: prepare_flags
      run: |
        FLAGS="-r $(pwd)/work"
        if [ "${{ github.event.inputs.silent_mode }}" == "true" ]; then FLAGS="$FLAGS -s"; fi
        if [ "${{ github.event.inputs.purge_all }}" == "true" ]; then FLAGS="$FLAGS -p"; fi
        if [ "${{ github.event.inputs.empty_product }}" == "true" ]; then FLAGS="$FLAGS -e"; fi
        if [ "${{ github.event.inputs.empty_system_ext }}" == "true" ]; then FLAGS="$FLAGS -x"; fi
        if [ "${{ github.event.inputs.writable }}" == "true" ]; then FLAGS="$FLAGS -w"; fi
        if [ -n "${{ github.event.inputs.no_flash_flag }}" ]; then FLAGS="$FLAGS ${{ github.event.inputs.no_flash_flag }}"; fi
        echo "flags=$FLAGS" >> $GITHUB_OUTPUT

    # This is the core step where the super partition is repacked.
    - name: Run repacksuper.sh
      run: |
        echo "==> Running repacksuper.sh with flags: ${{ steps.prepare_flags.outputs.flags }}"
        ./repacksuper.sh ${{ steps.prepare_flags.outputs.flags }} work/stock_super_sparse.img work/custom_system.img work/repacked_super.img
        rm -f work/stock_super_sparse.img work/custom_system.img

    # This step verifies, renames, and creates an uncompressed tarball as requested.
    - name: Verify, Rename, and Create Tarball
      id: create_tarball
      run: |
        cd work
        if [ ! -f "repacked_super.img" ]; then echo "✗ Error: repacked_super.img not found." && ls -la && exit 1; fi
        mv repacked_super.img super.img
        # Create an uncompressed tarball (-cvf) as requested.
        TARBALL_NAME="repacked_super_$(date +%Y%m%d).tar"
        tar -cvf "$TARBALL_NAME" super.img
        rm super.img
        echo "tarball_path=work/$TARBALL_NAME" >> $GITHUB_OUTPUT
        echo "tarball_name=$TARBALL_NAME" >> $GITHUB_OUTPUT

    # This step uploads the final tarball as a workflow artifact.
    - name: Upload Artifact
      uses: actions/upload-artifact@v4
      with:
        name: repacked-super-image
        path: ${{ steps.create_tarball.outputs.tarball_path }}

    # This step creates a GitHub Release if the user selected the option.
    - name: Create GitHub Release with Artifact
      if: github.event.inputs.upload_to_release == 'true'
      uses: softprops/action-gh-release@v2
      with:
        tag_name: repack-${{ github.run_id }}-${{ github.run_attempt }}
        name: "Repacked Super Image - ${{ github.run_id }}"
        body: |
          ## Repacked Super Image
          This release was generated automatically by the GitHub Actions workflow.
          ### Source Files
          *   **Stock Firmware:** `${{ github.event.inputs.stock_firmware_url }}`
          *   **Custom ROM:** `${{ github.event.inputs.custom_system_url }}`
        files: ${{ steps.create_tarball.outputs.tarball_path }}
        draft: false
        prerelease: false
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      continue-on-error: true

    # This step runs at the end of the job to show final disk space.
    - name: Final Space Check
      if: always()
      run: |
        echo "Final disk space:"
        df -h
