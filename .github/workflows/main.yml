name: Android Super Repack (Universal FS)

on:
  workflow_dispatch:
    inputs:
      device_preset:
        description: 'Select Stock Firmware Source'
        required: true
        default: 'none'
        type: choice
        options:
        - 'none (Use Custom URL below)'
        - 'Samsung A04s (64GB)'
        - 'Samsung A15 (128/256GB)'
      stock_firmware_url:
        description: 'Custom Stock Firmware URL (Required if preset is none)'
        required: false
        type: string
      custom_system_url:
        description: 'Custom ROM URL (LineageOS, etc.)'
        required: true
        type: string
      upload_to_release:
        description: 'Upload to Release?'
        required: true
        type: boolean
        default: false
      empty_product:
        description: 'Use empty product.img (-e)'
        required: false
        type: boolean
        default: false
      empty_system_ext:
        description: 'Use empty system_ext.img (-x)'
        required: false
        type: boolean
        default: false
      silent_mode:
        description: 'Silent mode (-s)'
        required: false
        type: boolean
        default: true
      writable:
        description: 'Make partitions writable (-w)'
        required: false
        type: boolean
        default: false

jobs:
  repack-super:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    # Disk Cleanup
    - name: Free disk space
      uses: jlumbroso/free-disk-space@main
      with:
        tool-cache: true
        android: true
        dotnet: true
        haskell: true
        large-packages: true
        swap-storage: true

    - name: Install Dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y android-sdk-libsparse-utils tar xz-utils liblz4-tool unzip p7zip-full file wget curl megatools f2fs-tools erofs-utils python3-pip
        pip install gdown
        curl -fsSL https://get.docker.com -o get-docker.sh
        sudo sh get-docker.sh

    - name: Verify and Prepare Script
      run: |
        if [ ! -f "./repacksuper.sh" ]; then echo "✗ Error: repacksuper.sh not found" && exit 1; fi
        chmod +x ./repacksuper.sh
        mkdir -p work

    - name: Download Stock Firmware
      run: |
        cd work
        PRESET="${{ github.event.inputs.device_preset }}"
        
        if [[ "$PRESET" == "Samsung A04s (64GB)" ]]; then
          echo "==> Downloading Samsung A04s Firmware..."
          # File ID: 1C9GtYTn1EZ4sQN7qfJeWN6gxDj_WbgY-
          gdown --output stock_firmware.zip '1C9GtYTn1EZ4sQN7qfJeWN6gxDj_WbgY-'
          
        elif [[ "$PRESET" == "Samsung A15 (128/256GB)" ]]; then
          echo "==> Downloading Samsung A15 Firmware..."
          # File ID: 12FoeBkPDHddj4lzd-T6pjHRQ8Ey3c2U8
          gdown --output stock_firmware.zip '12FoeBkPDHddj4lzd-T6pjHRQ8Ey3c2U8'
          
        else
          echo "==> Using Custom URL..."
          FIRMWARE_URL="${{ github.event.inputs.stock_firmware_url }}"
          if [ -z "$FIRMWARE_URL" ]; then echo "✗ Error: No preset selected and no URL provided." && exit 1; fi
          
          if [[ $FIRMWARE_URL == *"mega.nz"* ]]; then 
            megadl -o stock_firmware.zip "$FIRMWARE_URL"
          else 
            wget --content-disposition -O stock_firmware.zip "$FIRMWARE_URL"
          fi
        fi
        
        if [ ! -s "stock_firmware.zip" ]; then echo "✗ Error: Firmware download failed." && exit 1; fi
        
        # Extract AP file
        echo "==> Extracting AP file..."
        AP_FILENAME=$(unzip -l "stock_firmware.zip" | grep -i -o -E "AP_.*\.tar\.md5" | head -n 1)
        unzip -o -j "stock_firmware.zip" "$AP_FILENAME"
        rm "stock_firmware.zip"
        
        # Extract super.img.lz4
        echo "==> Extracting super.img.lz4..."
        tar -xvf "$AP_FILENAME" --wildcards '*super.img*.lz4'
        rm "$AP_FILENAME"
        
        # Decompress LZ4
        echo "==> Decompressing LZ4..."
        SUPER_LZ4=$(ls *super.img*.lz4 | head -n 1)
        lz4 -d "$SUPER_LZ4" stock_super_sparse.img
        rm "$SUPER_LZ4"

    - name: Download and Extract Custom System (FIXED)
      run: |
        cd work
        echo "==> Downloading Custom ROM..."
        wget -O custom_rom_package "${{ github.event.inputs.custom_system_url }}"
        
        # Determine file type
        FILE_DESC=$(file -b custom_rom_package)
        echo "Detected File Type: $FILE_DESC"

        # Extraction Logic
        if [[ "$FILE_DESC" == *"XZ compressed"* ]]; then
            mv custom_rom_package c.img.xz
            unxz c.img.xz
            mv c.img custom_system.img
            
        elif [[ "$FILE_DESC" == *"Zip archive"* ]]; then
            unzip -o custom_rom_package
            
        elif [[ "$FILE_DESC" == *"7-zip archive"* ]]; then
            7z x custom_rom_package
            
        elif [[ "$FILE_DESC" == *"gzip compressed"* ]]; then
            mv custom_rom_package c.img.gz
            gzip -d c.img.gz
            mv c.img custom_system.img
            
        else
            # Assume it's a raw image if no compression detected
            echo "Assuming raw image..."
            mv custom_rom_package custom_system.img
        fi
        
        # --- THE FIX: Find any extracted .img file ---
        # If custom_system.img doesn't exist yet (from zip/7z extraction)
        if [ ! -f "custom_system.img" ]; then
            echo "==> Searching for extracted .img file..."
            # Find largest .img file, excluding the stock super image we prepared earlier
            IMG_FILE=$(find . -type f -name "*.img" ! -name "stock_super_sparse.img" -printf "%s\t%p\n" | sort -n | tail -1 | cut -f2-)
            
            if [ -z "$IMG_FILE" ]; then
                echo "✗ Error: No .img file found after extraction!"
                ls -R
                exit 1
            fi
            
            echo "==> Found image: $IMG_FILE"
            mv "$IMG_FILE" custom_system.img
        fi
        
        echo "==> Custom system image prepared: custom_system.img"

    - name: Ensure Raw Image
      run: |
        cd work
        # Attempt conversion if sparse, otherwise keep raw
        mv custom_system.img custom_system.orig
        if simg2img custom_system.orig custom_system.img; then
          echo "Converted sparse to raw."
          rm custom_system.orig
        else
          echo "Image is likely already raw or EROFS. Using original."
          mv custom_system.orig custom_system.img
        fi

    - name: Branding Injection (Smart Mode)
      run: |
        cd work
        echo "==> Checking filesystem type for branding..."
        
        docker run --rm --privileged \
          -v "$(pwd):/work" \
          ubuntu:22.04 \
          bash -c '
            apt-get update -qq && apt-get install -y -qq e2fsprogs util-linux file
            cd /work
            
            # Identify Filesystem
            FS_TYPE=$(blkid -o value -s TYPE custom_system.img 2>/dev/null || echo "unknown")
            echo "Filesystem detected: $FS_TYPE"
            
            if [ "$FS_TYPE" = "ext4" ]; then
              echo "==> EXT4 detected. Injecting branding via debugfs..."
              echo "cat /system/build.prop" | debugfs custom_system.img > current_build.prop 2>/dev/null
              
              if [ -s current_build.prop ]; then
                 sed -i "s|ro\.build\.id=.*|ro.build.id=Built.By.Minh2077.Script|g" current_build.prop
                 echo "cd /system" > script.debugfs
                 echo "rm build.prop" >> script.debugfs
                 echo "write current_build.prop build.prop" >> script.debugfs
                 echo "quit" >> script.debugfs
                 debugfs -w -f script.debugfs custom_system.img
                 echo "==> Branding injected successfully."
              else
                 echo "==> Could not extract build.prop. Skipping."
              fi
            else
               echo "==> Filesystem is $FS_TYPE (EROFS/F2FS/Other). Skipping branding to ensure stability."
            fi
          '

    - name: Run Repack
      run: |
        # Construct flags
        FLAGS="-r $(pwd)/work"
        if [ "${{ github.event.inputs.silent_mode }}" == "true" ]; then FLAGS="$FLAGS -s"; fi
        if [ "${{ github.event.inputs.empty_product }}" == "true" ]; then FLAGS="$FLAGS -e"; fi
        if [ "${{ github.event.inputs.empty_system_ext }}" == "true" ]; then FLAGS="$FLAGS -x"; fi
        if [ "${{ github.event.inputs.writable }}" == "true" ]; then FLAGS="$FLAGS -w"; fi
        
        echo "Running with flags: $FLAGS"
        ./repacksuper.sh $FLAGS work/stock_super_sparse.img work/custom_system.img work/repacked_super.img

    - name: Create Tarball
      id: package
      run: |
        cd work
        if [ ! -f "repacked_super.img" ]; then echo "✗ Error: Repack failed, image not found." && exit 1; fi
        mv repacked_super.img super.img
        TAR_NAME="repacked_super_$(date +%Y%m%d).tar"
        tar -cvf "$TAR_NAME" super.img
        echo "tar_path=work/$TAR_NAME" >> $GITHUB_OUTPUT

    # --- RESTORED STEP: Upload to GitHub Artifacts ---
    - name: Upload Artifact
      uses: actions/upload-artifact@v4
      with:
        name: repacked-super-image
        path: ${{ steps.package.outputs.tar_path }}
        retention-days: 5

    - name: Upload Release
      if: github.event.inputs.upload_to_release == 'true'
      uses: softprops/action-gh-release@v2
      with:
        tag_name: build-${{ github.run_id }}
        files: ${{ steps.package.outputs.tar_path }}
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
